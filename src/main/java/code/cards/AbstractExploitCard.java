package code.cards;

import code.TheDisplaced;
import com.megacrit.cardcrawl.actions.GameActionManager;
import com.megacrit.cardcrawl.actions.common.ReducePowerAction;
import com.megacrit.cardcrawl.actions.common.RemoveSpecificPowerAction;
import com.megacrit.cardcrawl.cards.AbstractCard;
import com.megacrit.cardcrawl.dungeons.AbstractDungeon;
import com.megacrit.cardcrawl.monsters.AbstractMonster;
import com.megacrit.cardcrawl.powers.AbstractPower;

import java.util.function.Consumer;

import static code.util.charUtil.CardUtil.isPowerTurnBased;

public abstract class AbstractExploitCard extends AbstractEasyCard {

    private int exploitCost = 0;
    @Override
    public void triggerOnGlowCheck(){
        this.glowColor = AbstractCard.BLUE_BORDER_GLOW_COLOR.cpy();

        for(AbstractMonster mo : AbstractDungeon.getMonsters().monsters){
            if(isExploitable(mo)){
                this.glowColor = AbstractCard.GOLD_BORDER_GLOW_COLOR.cpy();
            }
        }
    }

    public AbstractExploitCard(final String cardID, final int cost, final CardType type, final CardRarity rarity, final CardTarget target, int exploitCostIn) {
        super(cardID, cost, type, rarity, target, TheDisplaced.Enums.DISPLACED_COLOR);
        this.exploitCost = exploitCostIn;
    }

    protected void exploitEffects(AbstractMonster mo, Consumer<GameActionManager> actions){
        if(isExploitable(mo)){
            if(actions != null) {
                actions.accept(AbstractDungeon.actionManager);
            }

            int costRemaining = exploitCost;

            for(int i = 0; i < mo.powers.size(); i++){
                AbstractPower power = mo.powers.get(i);
                if(power.type == AbstractPower.PowerType.DEBUFF && isPowerTurnBased(power)){
                    if(power.amount >= costRemaining){
                        AbstractDungeon.actionManager.addToBottom(new ReducePowerAction(mo, AbstractDungeon.player, power, exploitCost));
                        return;
                    }else{
                        AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(mo, AbstractDungeon.player, power));
                    }
                }
            }
        }
    }

    protected boolean isExploitable(AbstractMonster mo){
        int totalDebuffs = 0;

        for(int i = 0; i < mo.powers.size(); i++){
            AbstractPower power = mo.powers.get(i);
            if(power.type == AbstractPower.PowerType.DEBUFF && isPowerTurnBased(power)){
                totalDebuffs += power.amount;
                if(totalDebuffs >= exploitCost) return true;
            }
        }

        return false;
    }


}
